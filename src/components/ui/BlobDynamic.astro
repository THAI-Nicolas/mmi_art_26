---
/**
 * Composant BlobDynamic - Système de blobs avec variantes multiples
 * 
 * Gère plusieurs formes de blobs avec animations idle et hover personnalisées.
 * Supporte images et couleurs solides.
 * 
 * @prop variant - Numéro de variante (1-4, défaut: 1)
 * @prop imageUrl - URL de l'image à masquer (optionnel)
 * @prop color - Couleur de remplissage si pas d'image (défaut: "#000000")
 * @prop width - Largeur du SVG (optionnel, auto si non fourni)
 * @prop height - Hauteur du SVG (optionnel, auto si non fourni)
 * @prop className - Classes CSS additionnelles
 */
interface Props {
  variant?: 1 | 2 | 3 | 4;
  imageUrl?: string;
  color?: string;
  width?: number;
  height?: number;
  className?: string;
}

const {
  variant = 1,
  imageUrl,
  color = "#000000",
  width,
  height,
  className = "",
} = Astro.props;

// Configuration des variantes
const variants = {
  1: {
    path: "M254.667 9.66027C189.717 -19.3087 147.614 23.4234 135.312 51.8473L133.247 58.3172C137.675 114.386 77.5311 134.842 45.5481 136.984C-3.65639 146.796 -4.06644 194.61 3.72428 215.246C16.2923 248.537 28.7366 271.899 31.4018 282.412C28.4495 335.211 34.2721 356.976 37.5524 361.259C72.9796 422.001 135.961 407.984 163.024 393.382C210.26 359.274 248.312 362.038 261.433 367.684C308.669 399.456 351.231 401.559 366.608 398.639C446.319 373.408 432.214 312.588 415.197 285.333C394.039 232.067 424.013 179.425 441.645 159.762C490.849 88.2736 465.017 45.0927 445.95 32.4382C426.268 10.0107 368.453 31.4649 336.47 45.8715C313.713 52.2961 267.379 21.7307 254.667 9.66027Z",
    viewBox: "0 0 470 406",
    deformStrength: 0.3,
    animSpeed: 0.025,
    amplitude: 8,
    topLimit: 150,
  },
  2: {
    path: "M159.789 360.886C210.58 387.483 114.367 569.22 290.347 611.106C444.342 647.76 523.143 480.666 603.221 428.438C750.826 332.168 663.793 257.17 657.886 180.445C648.088 53.1946 608.476 28.7031 466.586 78.3009C412.5 97.207 390.752 -41.167 268.954 12.4137C168.69 56.5216 71.4368 -60.8943 7.10053 111.624C-22.7727 191.729 44.1785 300.345 159.789 360.886Z",
    viewBox: "0 0 689 617",
    defaultWidth: 470,
    defaultHeight: 420,
    deformStrength: 0.3,
    animSpeed: 0.025,
    amplitude: 6,
    topLimit: 100,
    leftLimit: 200,
  },
  3: {
    path: "M30.8747 572.006C92.8687 658.35 238.111 680.315 341.229 607.943C484.615 507.311 604.019 553.498 680.108 474.795C819.037 331.093 644.073 278.705 632.731 237.259C595.3 100.474 582.495 35.0566 414.169 5.0584C331.691 -9.64048 158.257 5.05841 114.75 84.315C36.433 226.986 117.498 193.374 76.8082 299.246C41.9947 389.829 -46.6178 464.076 30.8747 572.006Z",
    viewBox: "0 0 734 652",
    defaultWidth: 470,
    defaultHeight: 418,
    deformStrength: 0.3,
    animSpeed: 0.025,
    amplitude: 7,
    topLimit: 120,
    leftLimit: 150,
    bottomLimit: 500,
  },
  4: {
    path: "M10.545 175.984C22.386 207.122 -31.2426 246.509 46.6411 318.791C114.795 382.042 198.714 338.99 256.779 336.254C363.809 331.21 354.255 273.552 375.545 233.484C410.855 167.03 414.301 93.5973 325.045 76.9837C291.022 70.6509 266.259 8.38145 226.045 3.98375C185.831 -0.413942 116.141 -12.2094 86.6411 46.7901C63.6032 92.8655 -31.3586 65.7903 10.545 175.984Z",
    viewBox: "0 0 399 354",
    defaultWidth: 470,
    defaultHeight: 417,
    deformStrength: 0.3,
    animSpeed: 0.025,
    amplitude: 7,
    topLimit: 100,
    leftLimit: 100,
  },
};

const config = variants[variant];
const [vbX, vbY, vbWidth, vbHeight] = config.viewBox.split(" ").map(Number);

const uniqueId = `blob-dynamic-${variant}-${Math.random().toString(36).substr(2, 9)}`;
---

<div 
  class={`blob-dynamic-container ${className}`} 
  data-blob-id={uniqueId} 
  data-path={config.path}
  data-deform={config.deformStrength}
  data-speed={config.animSpeed}
  data-amplitude={config.amplitude}
  data-top-limit={config.topLimit}
  data-left-limit={config.leftLimit || 0}
  data-bottom-limit={config.bottomLimit || 9999}
>
  <svg
    class="blob-svg"
    {...(width ? { width } : {})}
    {...(height ? { height } : {})}
    viewBox={config.viewBox}
    xmlns="http://www.w3.org/2000/svg"
  >
    <defs>
      {imageUrl && (
        <clipPath id={`clip-${uniqueId}`}>
          <path id={`blob-path-${uniqueId}`} d={config.path} />
        </clipPath>
      )}
    </defs>

    {imageUrl ? (
      <image
        href={imageUrl}
        x="0"
        y="0"
        width={vbWidth}
        height={vbHeight}
        clip-path={`url(#clip-${uniqueId})`}
        preserveAspectRatio="xMidYMid slice"
      />
    ) : (
      <path
        id={`blob-path-${uniqueId}`}
        class="blob-morph"
        d={config.path}
        fill={color}
      />
    )}
  </svg>

</div>

<style>
  .blob-dynamic-container {
    position: relative;
    display: inline-block;
    overflow: hidden;
  }

  .blob-svg {
    display: block;
    width: 100%;
    height: auto;
  }

  .blob-morph {
    transition: all 0.2s ease-out;
  }
</style>

<script>
  document.addEventListener("astro:page-load", () => {
    initializeBlobs();
  });

  function initializeBlobs() {
    const containers = document.querySelectorAll(".blob-dynamic-container");

    containers.forEach((container) => {
      const blobId = container.getAttribute("data-blob-id");
      const svg = container.querySelector(".blob-svg") as SVGSVGElement;
      const blobPath = svg?.querySelector(`#blob-path-${blobId}`) as SVGPathElement;
      const originalPath = container.getAttribute("data-path");
      const deformStrength = parseFloat(container.getAttribute("data-deform") || "0.3");
      const animSpeed = parseFloat(container.getAttribute("data-speed") || "0.025");
      const amplitude = parseFloat(container.getAttribute("data-amplitude") || "8");
      const topLimit = parseFloat(container.getAttribute("data-top-limit") || "150");
      const leftLimit = parseFloat(container.getAttribute("data-left-limit") || "0");
      const bottomLimit = parseFloat(container.getAttribute("data-bottom-limit") || "9999");

      if (!svg || !blobPath || !originalPath) return;

      // Parser le path SVG pour extraire les points
      const points = parseSVGPath(originalPath);
      let mouseX = 0;
      let mouseY = 0;
      let isHovering = false;
      let time = 0;

      // Animation continue
      function animate() {
        time += animSpeed;

        // Déformer chaque point
        const deformedPoints = points.map((point, index) => {
          let newX = point.x;
          let newY = point.y;

          // Animation idle : TOUJOURS active
          const isTopArea = point.y < topLimit;
          const isLeftArea = leftLimit > 0 && point.x < leftLimit;
          const isBottomArea = bottomLimit < 9999 && point.y > bottomLimit;
          
          if (!isTopArea && !isLeftArea && !isBottomArea) {
            const wavePhase = time + index * 0.25;
            
            const offsetX = Math.sin(wavePhase) * amplitude;
            const offsetY = Math.cos(wavePhase * 0.7) * amplitude * 0.5;
            
            newX = point.x + offsetX;
            newY = point.y + offsetY;
          }

          // Répulsion souris : S'AJOUTE à l'animation idle quand hover
          if (isHovering) {
            const dx = mouseX - newX;
            const dy = mouseY - newY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxDistance = 150;

            if (distance < maxDistance) {
              const force = (1 - distance / maxDistance) * deformStrength * 50;
              const angle = Math.atan2(dy, dx);
              
              newX = newX - Math.cos(angle) * force;
              newY = newY - Math.sin(angle) * force;
            }
          }

          return {
            ...point,
            x: newX,
            y: newY,
          };
        });

        // Reconstruire le path
        const newPath = buildSVGPath(deformedPoints);
        blobPath.setAttribute("d", newPath);

        requestAnimationFrame(animate);
      }

      // Suivi de la souris
      svg.addEventListener("mousemove", (e) => {
        const rect = svg.getBoundingClientRect();
        const viewBoxParts = svg.getAttribute("viewBox")?.split(" ") || ["0", "0", "470", "406"];
        const viewBoxWidth = parseFloat(viewBoxParts[2]);
        const viewBoxHeight = parseFloat(viewBoxParts[3]);
        
        mouseX = ((e.clientX - rect.left) / rect.width) * viewBoxWidth;
        mouseY = ((e.clientY - rect.top) / rect.height) * viewBoxHeight;
      });

      svg.addEventListener("mouseenter", () => {
        isHovering = true;
      });

      svg.addEventListener("mouseleave", () => {
        isHovering = false;
      });

      // Démarrer l'animation
      animate();
    });
  }

  // Parser un path SVG pour extraire les coordonnées
  function parseSVGPath(pathString: string) {
    const points: Array<{ x: number; y: number; type: string }> = [];
    const commands = pathString.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/gi) || [];

    commands.forEach((cmd) => {
      const type = cmd[0];
      const coords = cmd
        .slice(1)
        .trim()
        .split(/[\s,]+/)
        .map(Number)
        .filter((n) => !isNaN(n));

      // Extraire les points selon le type de commande
      if (type === "M" || type === "L") {
        for (let i = 0; i < coords.length; i += 2) {
          points.push({ x: coords[i], y: coords[i + 1], type });
        }
      } else if (type === "C") {
        for (let i = 0; i < coords.length; i += 6) {
          points.push({ x: coords[i], y: coords[i + 1], type: "C1" });
          points.push({ x: coords[i + 2], y: coords[i + 3], type: "C2" });
          points.push({ x: coords[i + 4], y: coords[i + 5], type });
        }
      }
    });

    return points;
  }

  // Reconstruire un path SVG depuis les points
  function buildSVGPath(points: Array<{ x: number; y: number; type: string }>) {
    let path = "";
    let i = 0;

    while (i < points.length) {
      const point = points[i];
      
      if (point.type === "M") {
        path += `M${point.x},${point.y} `;
        i++;
      } else if (point.type === "C") {
        const c1 = points[i - 2];
        const c2 = points[i - 1];
        path += `C${c1.x},${c1.y} ${c2.x},${c2.y} ${point.x},${point.y} `;
        i++;
      } else if (point.type === "L") {
        path += `L${point.x},${point.y} `;
        i++;
      } else {
        i++;
      }
    }

    return path + "Z";
  }

  // Initialisation immédiate
  if (document.readyState !== "loading") {
    initializeBlobs();
  }
</script>
